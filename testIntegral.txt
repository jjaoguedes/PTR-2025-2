// src/main.c
//
// Testes para a API de integração numérica (integral.h / integral.c).
// Como compilar/executar com o Makefile:
//   $ make
//   $ ./lab1

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "integral.h"

// --- Definições portáveis para constantes matemáticas (caso não existam) ---
#ifndef M_PI
#define M_PI 3.14159265358979323846264338327950288419716939937510
#endif
#ifndef M_E
#define M_E  2.71828182845904523536028747135266249775724709369995
#endif

// ---------- Utilidades de teste ----------

static int almost_equal(double a, double b, double tol) {
    return fabs(a - b) <= tol;
}

#define CHECK(cond, msg)                                      \
    do {                                                      \
        if (cond) {                                           \
            (*passes)++;                                      \
            if (verbose) printf("  [OK]   %s\n", msg);        \
        } else {                                              \
            (*fails)++;                                       \
            printf("  [FAIL] %s\n", msg);                     \
        }                                                     \
    } while (0)

// Tolerância baseada na ordem de convergência de cada método.
// span = |b-a| ajuda a escalar pelo tamanho do intervalo.
// Constantes C foram escolhidas de forma conservadora para evitar falsos FAILs.
static double default_tol(const char* method_name, size_t n, double span) {
    if (n == 0) n = 1;
    double s = fmax(1.0, span);

    // Heurísticos (conservadores):
    //   Riemann L/R:   ~ C1 * s / n
    //   Trap/Mid:      ~ C2 * s / n^2
    //   Simpson:       ~ C3 * s / n^4  (com piso mínimo)
    double tol;

    int is_left  = strstr(method_name, "Left")      != NULL;
    int is_right = strstr(method_name, "Right")     != NULL;
    int is_mid   = strstr(method_name, "Midpoint")  != NULL || strstr(method_name, "Mid") != NULL;
    int is_trap  = strstr(method_name, "Trap")      != NULL;
    int is_simp  = strstr(method_name, "Simpson")   != NULL;

    if (is_left || is_right) {
        // Observado ~5e-4 com n=1000 para x^2 em [0,1]. Use algo folgado:
        tol = s * (2.0 / (double)n) + 1e-12; // 2/n cobre bem casos típicos
    } else if (is_trap || is_mid) {
        // Erros ~1e-7 a 1e-8 com n=1000 -> use ~5/n^2
        tol = s * (5.0 / ((double)n * (double)n)) + 1e-12;
    } else if (is_simp) {
        // Simpson converge muito rápido; com n=1000 ~1e-12. Damos folga:
        double n4 = (double)n*(double)n*(double)n*(double)n;
        tol = s * (50.0 / n4);
        if (tol < 5e-12) tol = 5e-12; // piso para evitar exigir além de double
    } else {
        // fallback genérico
        tol = s * (1.0 / ((double)n * (double)n)) + 1e-9;
    }
    return tol;
}

// Tipo para ponteiro de função integradora
typedef double (*IntegratorFn)(Func1D, void*, double, double, size_t, IntegralStatus*);

// ---------- Funções de teste (f, ctx) ----------

static double f_x2(double x, void* ctx) { (void)ctx; return x*x; }
static double f_sin(double x, void* ctx) { (void)ctx; return sin(x); }
static double f_inv(double x, void* ctx) { (void)ctx; return 1.0/x; }

typedef struct { double c; } ConstCtx;
static double f_const(double x, void* ctx) { (void)x; return ((ConstCtx*)ctx)->c; }

typedef struct { double a, b; } LinCtx;
static double f_lin(double x, void* ctx) { LinCtx* L = (LinCtx*)ctx; return L->a * x + L->b; }

// ---------- Blocos de teste ----------

static void run_numeric_test(
    const char* title,
    IntegratorFn integrator, const char* method_name,
    Func1D f, void* ctx,
    double a, double b, size_t n,
    double expected,
    int *passes, int *fails,
    int verbose
) {
    printf("\n== %s | Método: %s ==\n", title, method_name);
    IntegralStatus st = -999;
    double span = fabs(b - a);
    double tol = default_tol(method_name, n, span);

    double got = integrator(f, ctx, a, b, n, &st);
    if (verbose) {
        printf("  Intervalo   : [%.10g, %.10g], n = %zu\n", a, b, n);
        printf("  Esperado    : %.12g\n", expected);
        printf("  Obtido      : %.12g\n", got);
        printf("  Tolerância  : %.3g\n", tol);
        printf("  Status      : %d\n", st);
    }

    CHECK(st == INT_OK, "Status deve ser INT_OK");
    CHECK(almost_equal(got, expected, tol), "Valor numérico dentro da tolerância");
}

static void run_error_test(
    const char* title,
    IntegratorFn integrator, const char* method_name,
    Func1D f, void* ctx,
    double a, double b, size_t n,
    IntegralStatus expected_status,
    int *passes, int *fails,
    int verbose
) {
    printf("\n== %s | Método: %s ==\n", title, method_name);
    IntegralStatus st = -999;
    double got = integrator(f, ctx, a, b, n, &st);
    (void)got;

    if (verbose) {
        printf("  Intervalo: [%.10g, %.10g], n = %zu\n", a, b, n);
        printf("  Status esperado: %d, obtido: %d\n", expected_status, st);
    }

    CHECK(st == expected_status, "Status de erro conforme esperado");
}

static void run_zero_interval_test(
    IntegratorFn integrator, const char* method_name,
    Func1D f, void* ctx, double a,
    int *passes, int *fails, int verbose
) {
    printf("\n== Intervalo nulo | Método: %s ==\n", method_name);
    IntegralStatus st = -999;
    double got = integrator(f, ctx, a, a, 10, &st);
    if (verbose) {
        printf("  a == b == %.10g\n", a);
        printf("  Obtido: %.12g, Status: %d\n", got, st);
    }
    CHECK(st == INT_OK, "Status INT_OK quando a == b");
    CHECK(almost_equal(got, 0.0, 1e-15), "Integral em intervalo nulo deve ser 0");
}

static void run_inverted_interval_test(
    IntegratorFn integrator, const char* method_name,
    Func1D f, void* ctx,
    double a, double b, size_t n,
    double expected_forward,
    int *passes, int *fails, int verbose
) {
    printf("\n== Intervalo invertido | Método: %s ==\n", method_name);
    IntegralStatus st1 = -999, st2 = -999;

    double g1 = integrator(f, ctx, a, b, n, &st1);
    double g2 = integrator(f, ctx, b, a, n, &st2);

    double tol = default_tol(method_name, n, fabs(b - a));
    if (verbose) {
        printf("  Direta   [%g, %g]: got=%.12g  (st=%d)  ~ %.12g\n", a, b, g1, st1, expected_forward);
        printf("  Invertida[%g, %g]: got=%.12g  (st=%d)  ~ -%.12g\n", b, a, g2, st2, expected_forward);
        printf("  Tol = %.3g\n", tol);
    }
    CHECK(st1 == INT_OK && st2 == INT_OK, "Status INT_OK para ambas as direções");
    CHECK(almost_equal(g1, expected_forward, tol), "Direta dentro da tolerância");
    CHECK(almost_equal(g2, -expected_forward, tol), "Invertida é o negativo da direta");
}

// ---------- MAIN ----------

int main(void) {
    int passes = 0, fails = 0;
    const int verbose = 1;

    // 1) Correção numérica

    // x^2 em [0,1] = 1/3
    {
        const double a = 0.0, b = 1.0, expected = 1.0/3.0;
        const size_t n_trap = 1000;
        const size_t n_simp = 1000;

        run_numeric_test("∫ x^2 dx em [0,1]",
                         riemann_left, "Riemann Left",
                         f_x2, NULL, a, b, n_trap, expected,
                         &passes, &fails, verbose);

        run_numeric_test("∫ x^2 dx em [0,1]",
                         riemann_right, "Riemann Right",
                         f_x2, NULL, a, b, n_trap, expected,
                         &passes, &fails, verbose);

        run_numeric_test("∫ x^2 dx em [0,1]",
                         riemann_midpoint, "Riemann Midpoint",
                         f_x2, NULL, a, b, n_trap, expected,
                         &passes, &fails, verbose);

        run_numeric_test("∫ x^2 dx em [0,1]",
                         midpoint_rule, "Midpoint (composta)",
                         f_x2, NULL, a, b, n_trap, expected,
                         &passes, &fails, verbose);

        run_numeric_test("∫ x^2 dx em [0,1]",
                         trapezoidal_rule, "Trapézio (composta)",
                         f_x2, NULL, a, b, n_trap, expected,
                         &passes, &fails, verbose);

        run_numeric_test("∫ x^2 dx em [0,1]",
                         simpson_rule, "Simpson (composta)",
                         f_x2, NULL, a, b, n_simp, expected,
                         &passes, &fails, verbose);
    }

    // sin(x) em [0,pi] = 2
    {
        const double a = 0.0, b = M_PI, expected = 2.0;
        const size_t n_trap = 2000;
        const size_t n_simp = 2000;

        run_numeric_test("∫ sin(x) dx em [0,pi]",
                         trapezoidal_rule, "Trapézio (composta)",
                         f_sin, NULL, a, b, n_trap, expected,
                         &passes, &fails, verbose);

        run_numeric_test("∫ sin(x) dx em [0,pi]",
                         simpson_rule, "Simpson (composta)",
                         f_sin, NULL, a, b, n_simp, expected,
                         &passes, &fails, verbose);
    }

    // 1/x em [1,e] = 1
    {
        const double a = 1.0, b = M_E, expected = 1.0;
        const size_t n_trap = 2000;
        const size_t n_simp = 2000;

        run_numeric_test("∫ (1/x) dx em [1,e]",
                         trapezoidal_rule, "Trapézio (composta)",
                         f_inv, NULL, a, b, n_trap, expected,
                         &passes, &fails, verbose);

        run_numeric_test("∫ (1/x) dx em [1,e]",
                         simpson_rule, "Simpson (composta)",
                         f_inv, NULL, a, b, n_simp, expected,
                         &passes, &fails, verbose);
    }

    // (ax+b) com contexto
    {
        LinCtx L = {.a = 2.5, .b = -1.0};
        const double a = -2.0, b = 3.0;
        const double expected = 0.5*L.a*(b*b - a*a) + L.b*(b - a);
        const size_t n_trap = 500;
        const size_t n_simp = 500;

        run_numeric_test("∫ (ax+b) dx com ctx",
                         trapezoidal_rule, "Trapézio (composta)",
                         f_lin, &L, a, b, n_trap, expected,
                         &passes, &fails, verbose);

        run_numeric_test("∫ (ax+b) dx com ctx",
                         simpson_rule, "Simpson (composta)",
                         f_lin, &L, a, b, n_simp, expected,
                         &passes, &fails, verbose);
    }

    // cte com contexto
    {
        ConstCtx C = {.c = 3.25};
        const double a = 5.0, b = 8.5;
        const double expected = C.c * (b - a);
        const size_t n_mid = 10;

        run_numeric_test("∫ cte dx com ctx",
                         midpoint_rule, "Midpoint (composta)",
                         f_const, &C, a, b, n_mid, expected,
                         &passes, &fails, verbose);
    }

    // 2) Casos de borda

    run_zero_interval_test(riemann_left,  "Riemann Left",  f_x2, NULL, 2.0, &passes, &fails, verbose);
    run_zero_interval_test(riemann_right, "Riemann Right", f_x2, NULL, 2.0, &passes, &fails, verbose);
    run_zero_interval_test(riemann_midpoint, "Riemann Midpoint", f_x2, NULL, 2.0, &passes, &fails, verbose);
    run_zero_interval_test(trapezoidal_rule, "Trapézio (composta)", f_x2, NULL, 2.0, &passes, &fails, verbose);
    run_zero_interval_test(simpson_rule, "Simpson (composta)", f_x2, NULL, 2.0, &passes, &fails, verbose);

    {
        const double a = 0.0, b = 1.0, expected_forward = 1.0/3.0;
        const size_t n = 1000;

        run_inverted_interval_test(riemann_left, "Riemann Left",
                                   f_x2, NULL, a, b, n, expected_forward, &passes, &fails, verbose);
        run_inverted_interval_test(trapezoidal_rule, "Trapézio (composta)",
                                   f_x2, NULL, a, b, n, expected_forward, &passes, &fails, verbose);
        run_inverted_interval_test(simpson_rule, "Simpson (composta)",
                                   f_x2, NULL, a, b, n, expected_forward, &passes, &fails, verbose);
    }

    // 3) Testes de erro/validação

    run_error_test("n == 0 deve falhar",
                   riemann_left, "Riemann Left",
                   f_x2, NULL, 0.0, 1.0, 0, INT_ERR_N_INVALID, &passes, &fails, verbose);

    run_error_test("n == 0 deve falhar",
                   trapezoidal_rule, "Trapézio (composta)",
                   f_x2, NULL, 0.0, 1.0, 0, INT_ERR_N_INVALID, &passes, &fails, verbose);

    run_error_test("f == NULL deve falhar",
                   riemann_midpoint, "Riemann Midpoint",
                   NULL, NULL, 0.0, 1.0, 10, INT_ERR_NULL_FUNC, &passes, &fails, verbose);

    run_error_test("Simpson com n ímpar deve falhar",
                   simpson_rule, "Simpson (composta)",
                   f_x2, NULL, 0.0, 1.0, 9, INT_ERR_N_INVALID, &passes, &fails, verbose);

    printf("\n================= RESUMO DOS TESTES =================\n");
    printf("Passes: %d\nFalhas: %d\n", passes, fails);
    printf("=====================================================\n");

    return (fails == 0) ? 0 : 1;
}
